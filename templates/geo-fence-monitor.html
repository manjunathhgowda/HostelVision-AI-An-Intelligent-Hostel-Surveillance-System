{% extends 'base.html' %}
{% block content %}
<div class="container mt-4">
<h3>Zone-Violation Monitor</h3>
<div class="container-fluid">

    <!-- Top row: Left (Live Feed) | Right (Set Boundary + Debug Output) -->
    <div class="row">
        <!-- Live Camera Feed -->
        <div class="col-md-6">
            <h3>Live Feed</h3>
            <div style="position: relative;">
                <video id="videoFeed" autoplay playsinline style="width: 100%;"></video>
                <canvas id="boundaryCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
            </div>
            <button id="startMonitoring" class="btn btn-success mt-2">Start Monitoring</button>
            <button id="stopMonitoring" class="btn btn-danger mt-2" disabled>Stop Monitoring</button>
            <p id="statusMessage" class="mt-2"></p>
        </div>

        <!-- Set Boundary + Debug Output -->
        <div class="col-md-6">
            <h3>Set Geo-Fence Boundary</h3>
            <p>Click on the video to add boundary points. Minimum 3 points required.</p>
            <button id="setBoundary" class="btn btn-primary">Set Boundary</button>
            <button id="saveBoundary" class="btn btn-success" disabled>Save Boundary</button>
            <button id="clearPoints" class="btn btn-secondary" disabled>Clear Points</button>

            <!-- Debug Output just below buttons -->
            <div class="mt-4">
                <h4>Debug Output</h4>
                <img id="debugImage" src="{{ url_for('static', filename='media/fg.gif') }}" 
                    style="width: 100%; display: none;" alt="Debug Image">
            </div>
        </div>
    </div>

    <!-- Breach Table Full Width -->
    <div class="row mt-4">
        <div class="col-md-12">
            <h3>Geo-Fence Breaches</h3>
            <table class="table table-bordered" id="breachTable">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Photo</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {% for entry in geo_fence_breaches %}
                    <tr>
                        <td>{{ entry.user_id }}</td>
                        <td><img src="{{ entry.image_url }}" alt="Breach" style="width: 100px;"></td>
                        <td>{{ entry.date }}</td>
                        <td>{{ entry.time }}</td>
                        <td>{{ entry.status }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

</div>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const video = document.getElementById('videoFeed');
    const canvas = document.getElementById('boundaryCanvas');
    const debugImage = document.getElementById('debugImage');
    const startBtn = document.getElementById('startMonitoring');
    const stopBtn = document.getElementById('stopMonitoring');
    const setBoundaryBtn = document.getElementById('setBoundary');
    const saveBoundaryBtn = document.getElementById('saveBoundary');
    const clearBoundaryBtn = document.getElementById('clearPoints');
    const statusDiv = document.getElementById('statusMessage');
    const breachTable = document.querySelector('#breachTable tbody');
    let stream = null;
    let boundaryPoints = [];
    let isMonitoring = false;
    let isSettingBoundary = false;
    const ctx = canvas.getContext('2d');

    // ✅ Function to show debug image (placeholder or actual)
    function showDebugImage(imageUrl = null) {
        if (!debugImage) return;

        if (imageUrl) {
            debugImage.src = imageUrl + '?' + new Date().getTime(); // Prevent caching
        } else {
            debugImage.src = "/static/fg.gif"; // Default placeholder
        }

        debugImage.style.display = 'block';
    }

    // Validate elements
    if (!video || !canvas || !debugImage || !startBtn || !stopBtn || !setBoundaryBtn || !saveBoundaryBtn || !clearBoundaryBtn || !statusDiv || !breachTable) {
        console.error('Missing critical DOM elements:', { video, canvas, debugImage, startBtn, stopBtn, setBoundaryBtn, saveBoundaryBtn, clearBoundaryBtn, statusDiv, breachTable });
        statusDiv.innerHTML = '<div class="text-danger">Error: Missing critical elements. Check HTML IDs.</div>';
        return;
    }

    async function startCamera(retryCount = 0, maxRetries = 3) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusDiv.innerHTML = '<div class="text-danger">Camera not supported by this browser.</div>';
            return;
        }

        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await video.play();
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            statusDiv.innerHTML = '<div class="text-success">Camera started successfully.</div>';

            // Load saved boundary
            try {
                const response = await fetch('/get_geo_fence_boundary');
                const data = await response.json();
                if (data.status === 'success' && data.boundary && data.boundary.length > 0) {
                    boundaryPoints = data.boundary;
                    drawBoundary();
                    statusDiv.innerHTML = '<div class="text-success">Loaded saved boundary.</div>';
                } else {
                    statusDiv.innerHTML = '<div class="text-info">No saved boundary found. Please set a new boundary.</div>';
                }
            } catch (err) {
                statusDiv.innerHTML = `<div class="text-danger">Error loading boundary: ${err.message}</div>`;
            }
        } catch (err) {
            statusDiv.innerHTML = `<div class="text-danger">Camera error: ${err.name} - ${err.message}</div>`;
            if (retryCount < maxRetries) {
                setTimeout(() => startCamera(retryCount + 1, maxRetries), 1000);
            } else {
                statusDiv.innerHTML = '<div class="text-danger">Failed to start camera after retries.</div>';
            }
        }
    }

    function drawBoundary() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (boundaryPoints.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            ctx.moveTo(boundaryPoints[0].x, boundaryPoints[0].y);
            for (let i = 1; i < boundaryPoints.length; i++) {
                ctx.lineTo(boundaryPoints[i].x, boundaryPoints[i].y);
            }
            if (boundaryPoints.length >= 3) {
                ctx.closePath();
            }
            ctx.stroke();
            boundaryPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
            });
        }
        saveBoundaryBtn.disabled = boundaryPoints.length < 3;
    }

    async function updateBreachTable() {
        try {
            const response = await fetch('/geo-fence-monitor');
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const newTableBody = doc.querySelector('#breachTable tbody');
            if (newTableBody) {
                breachTable.innerHTML = newTableBody.innerHTML;
            } else {
                statusDiv.innerHTML = '<div class="text-danger">Error: Table body not found in response.</div>';
            }
        } catch (err) {
            statusDiv.innerHTML = `<div class="text-danger">Error updating table: ${err.message}</div>`;
        }
    }

    canvas.addEventListener('click', (event) => {
        if (!isSettingBoundary) return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        boundaryPoints.push({ x, y });
        drawBoundary();
    });

    setBoundaryBtn.addEventListener('click', () => {
        isSettingBoundary = !isSettingBoundary;
        if (isSettingBoundary) {
            boundaryPoints = [];
            setBoundaryBtn.textContent = 'Cancel Boundary Setting';
            setBoundaryBtn.classList.replace('btn-primary', 'btn-danger');
            saveBoundaryBtn.disabled = true;
            clearBoundaryBtn.disabled = false;
            startBtn.disabled = true;
            statusDiv.innerHTML = '<div class="text-info">Click on the video to add boundary points.</div>';
            drawBoundary();
        } else {
            setBoundaryBtn.textContent = 'Set Boundary';
            setBoundaryBtn.classList.replace('btn-danger', 'btn-primary');
            saveBoundaryBtn.disabled = boundaryPoints.length < 3;
            clearBoundaryBtn.disabled = true;
            startBtn.disabled = false;
            statusDiv.innerHTML = '<div class="text-info">Boundary setting cancelled.</div>';
            drawBoundary();
        }
    });

    saveBoundaryBtn.addEventListener('click', async () => {
        if (boundaryPoints.length < 3) {
            statusDiv.innerHTML = '<div class="text-danger">Minimum 3 points required to save boundary.</div>';
            return;
        }
        try {
            const response = await fetch('/save_geo_fence_boundary', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ boundary: boundaryPoints })
            });
            const data = await response.json();
            statusDiv.innerHTML = `<div class="text-${data.status === 'success' ? 'success' : 'danger'}">${data.message}</div>`;
            if (data.status === 'success') {
                isSettingBoundary = false;
                setBoundaryBtn.textContent = 'Set Boundary';
                setBoundaryBtn.classList.replace('btn-danger', 'btn-primary');
                saveBoundaryBtn.disabled = true;
                clearBoundaryBtn.disabled = true;
                startBtn.disabled = false;
            }
        } catch (err) {
            statusDiv.innerHTML = `<div class="text-danger">Error saving boundary: ${err.message}</div>`;
        }
    });

    clearBoundaryBtn.addEventListener('click', () => {
        boundaryPoints = [];
        drawBoundary();
        statusDiv.innerHTML = '<div class="text-info">Boundary points cleared.</div>';
    });

    startBtn.addEventListener('click', () => {
        if (boundaryPoints.length < 3) {
            statusDiv.innerHTML = '<div class="text-danger">Please define a valid geo-fence boundary (min 3 points).</div>';
            return;
        }
        isMonitoring = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        showDebugImage();  // ✅ show default image
        statusDiv.innerHTML = '<div class="text-success">Monitoring started.</div>';
        processFrame();
    });

    stopBtn.addEventListener('click', () => {
        isMonitoring = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        debugImage.style.display = 'none';  // ✅ hide image completely
        statusDiv.innerHTML = '<div class="text-info">Monitoring stopped.</div>';
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            video.srcObject = null;
        }
    });

    async function processFrame() {
        if (!isMonitoring) return;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = video.videoWidth || 640;
        tempCanvas.height = video.videoHeight || 480;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

        tempCanvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('image', blob, 'frame.jpg');
            formData.append('boundary', JSON.stringify(boundaryPoints));

            try {
                const response = await fetch('/process_geo_fence', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.debug_image) {
                    showDebugImage(result.debug_image); // ✅ actual debug image
                } else {
                    debugImage.style.display = 'none';
                }

                statusDiv.innerHTML = result.message
                    .split('; ')
                    .map(msg => `<div class="text-${result.status === 'success' ? 'success' : 'danger'}">${msg}</div>`)
                    .join('');

                if (result.status === 'success' && result.message.includes('breach')) {
                    updateBreachTable();
                }
            } catch (err) {
                statusDiv.innerHTML = `<div class="text-danger">Error processing frame: ${err.message}</div>`;
            }

            if (isMonitoring) {
                setTimeout(processFrame, 100);
            }
        }, 'image/jpeg', 0.8);
    }
    showDebugImage();
    startCamera();
    updateBreachTable();
    setInterval(updateBreachTable, 30000);
});

    </script>
    </div>
{% endblock %}